package keystone

import (
	"context"
	"errors"
	"sort"
	"testing"
)

// mockTranslator is a test implementation of Translator
type mockTranslator struct {
	translateFunc func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error)
	calls         []TranslateRequest
}

func (m *mockTranslator) Translate(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
	m.calls = append(m.calls, req)
	if m.translateFunc != nil {
		return m.translateFunc(ctx, req)
	}
	// Default: return simple translations with "[lang]:" prefix
	resp := &TranslateResponse{Translations: make(map[string]*Translation)}
	for _, lang := range req.TargetLanguages {
		resp.Translations[lang] = &Translation{
			Singular: lang + ":" + req.Singular,
			Plural:   lang + ":" + req.Plural,
		}
	}
	return resp, nil
}

func newMockTranslator() *mockTranslator {
	return &mockTranslator{}
}

func newMockConfig(translator Translator, targets ...string) *TranslatorConfig {
	config := &TranslatorConfig{
		Translator: translator,
	}
	if len(targets) > 0 {
		config.TargetLanguages = targets
	}
	return config
}

// --- NoOpTranslator Tests ---

func TestNoOpTranslator_ReturnsEmptyTranslations(t *testing.T) {
	noop := NoOpTranslator()
	resp, err := noop.Translate(context.Background(), TranslateRequest{
		SourceLanguage:  "en",
		Singular:        "Hello",
		TargetLanguages: []string{"fr", "de"},
	})
	if err != nil {
		t.Fatalf("NoOpTranslator returned error: %v", err)
	}
	if resp == nil {
		t.Fatal("NoOpTranslator returned nil response")
	}
	if len(resp.Translations) != 0 {
		t.Errorf("Expected 0 translations, got %d", len(resp.Translations))
	}
}

// --- TranslatorConfig Tests ---

func TestTranslatorConfig_GetSourceLanguage_Default(t *testing.T) {
	config := &TranslatorConfig{}
	if config.GetSourceLanguage() != "en" {
		t.Errorf("Expected default source language 'en', got '%s'", config.GetSourceLanguage())
	}
}

func TestTranslatorConfig_GetSourceLanguage_Custom(t *testing.T) {
	config := &TranslatorConfig{SourceLanguage: "fr"}
	if config.GetSourceLanguage() != "fr" {
		t.Errorf("Expected source language 'fr', got '%s'", config.GetSourceLanguage())
	}
}

func TestTranslatorConfig_GetTargetLanguages_Default(t *testing.T) {
	config := &TranslatorConfig{}
	targets := config.GetTargetLanguages()
	if len(targets) != len(DefaultTargetLanguages) {
		t.Errorf("Expected %d default target languages, got %d", len(DefaultTargetLanguages), len(targets))
	}
	for i, lang := range targets {
		if lang != DefaultTargetLanguages[i] {
			t.Errorf("Expected target[%d]='%s', got '%s'", i, DefaultTargetLanguages[i], lang)
		}
	}
}

func TestTranslatorConfig_GetTargetLanguages_Custom(t *testing.T) {
	config := &TranslatorConfig{TargetLanguages: []string{"es", "fr"}}
	targets := config.GetTargetLanguages()
	if len(targets) != 2 {
		t.Fatalf("Expected 2 target languages, got %d", len(targets))
	}
	if targets[0] != "es" || targets[1] != "fr" {
		t.Errorf("Expected [es, fr], got %v", targets)
	}
}

// --- AutoTranslate Tests ---

func TestAutoTranslate_NilConfig(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	err := tr.AutoTranslate(context.Background(), nil)
	if !errors.Is(err, ErrNoTranslator) {
		t.Errorf("Expected ErrNoTranslator, got %v", err)
	}
}

func TestAutoTranslate_NilTranslator(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	err := tr.AutoTranslate(context.Background(), &TranslatorConfig{})
	if !errors.Is(err, ErrNoTranslator) {
		t.Errorf("Expected ErrNoTranslator, got %v", err)
	}
}

func TestAutoTranslate_NoSourceText(t *testing.T) {
	tr := &Translations{}
	mock := newMockTranslator()
	config := newMockConfig(mock, "fr", "de")
	err := tr.AutoTranslate(context.Background(), config)
	if !errors.Is(err, ErrNoSourceText) {
		t.Errorf("Expected ErrNoSourceText, got %v", err)
	}
}

func TestAutoTranslate_EmptySourceText(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "")
	mock := newMockTranslator()
	config := newMockConfig(mock, "fr", "de")
	err := tr.AutoTranslate(context.Background(), config)
	if !errors.Is(err, ErrNoSourceText) {
		t.Errorf("Expected ErrNoSourceText, got %v", err)
	}
}

func TestAutoTranslate_BasicTranslation(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	mock := newMockTranslator()
	config := newMockConfig(mock, "fr", "de")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	fr, ok := tr.Get("fr")
	if !ok || fr.Singular != "fr:Hello" {
		t.Errorf("Expected fr translation 'fr:Hello', got %v (ok=%v)", fr, ok)
	}

	de, ok := tr.Get("de")
	if !ok || de.Singular != "de:Hello" {
		t.Errorf("Expected de translation 'de:Hello', got %v (ok=%v)", de, ok)
	}

	if !tr.IsAutoGenerated("fr") {
		t.Error("Expected 'fr' to be marked as auto-generated")
	}
	if !tr.IsAutoGenerated("de") {
		t.Error("Expected 'de' to be marked as auto-generated")
	}
}

func TestAutoTranslate_WithPluralForms(t *testing.T) {
	tr := &Translations{}
	tr.AddT("en", &Translation{Singular: "cat", Plural: "cats"})
	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	if len(mock.calls) != 1 {
		t.Fatalf("Expected 1 translate call, got %d", len(mock.calls))
	}
	if mock.calls[0].Plural != "cats" {
		t.Errorf("Expected plural 'cats' in request, got '%s'", mock.calls[0].Plural)
	}

	fr, ok := tr.Get("fr")
	if !ok {
		t.Fatal("Expected fr translation to exist")
	}
	if fr.Plural != "fr:cats" {
		t.Errorf("Expected fr plural 'fr:cats', got '%s'", fr.Plural)
	}
}

func TestAutoTranslate_SkipsUserProvidedTranslations(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	tr.Add("fr", "Bonjour") // User-provided French

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr", "de")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	// French should NOT have been overridden
	fr, ok := tr.Get("fr")
	if !ok || fr.Singular != "Bonjour" {
		t.Errorf("Expected fr='Bonjour' (user-provided), got %v", fr)
	}

	if tr.IsAutoGenerated("fr") {
		t.Error("User-provided 'fr' should not be marked as auto-generated")
	}

	de, ok := tr.Get("de")
	if !ok || de.Singular != "de:Hello" {
		t.Errorf("Expected de translation 'de:Hello', got %v", de)
	}

	// Verify only 'de' was requested
	if len(mock.calls) != 1 {
		t.Fatalf("Expected 1 translate call, got %d", len(mock.calls))
	}
	if len(mock.calls[0].TargetLanguages) != 1 || mock.calls[0].TargetLanguages[0] != "de" {
		t.Errorf("Expected target languages [de], got %v", mock.calls[0].TargetLanguages)
	}
}

func TestAutoTranslate_OverridesAutoGeneratedTranslations(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	// First auto-translate
	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("First AutoTranslate returned error: %v", err)
	}

	// Update mock to return different text
	mock.translateFunc = func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
		return &TranslateResponse{
			Translations: map[string]*Translation{
				"fr": {Singular: "Salut"},
			},
		}, nil
	}

	// Second auto-translate should override auto-generated French
	err = tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("Second AutoTranslate returned error: %v", err)
	}

	fr, ok := tr.Get("fr")
	if !ok || fr.Singular != "Salut" {
		t.Errorf("Expected fr='Salut' after re-translation, got %v", fr)
	}
}

func TestAutoTranslate_SkipsSourceLanguageInTargets(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	mock := newMockTranslator()
	config := newMockConfig(mock, "en", "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	if len(mock.calls) != 1 {
		t.Fatalf("Expected 1 call, got %d", len(mock.calls))
	}
	if len(mock.calls[0].TargetLanguages) != 1 || mock.calls[0].TargetLanguages[0] != "fr" {
		t.Errorf("Expected target [fr], got %v", mock.calls[0].TargetLanguages)
	}
}

func TestAutoTranslate_AllTargetsHaveUserTranslations(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	tr.Add("fr", "Bonjour")
	tr.Add("de", "Hallo")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr", "de")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	if len(mock.calls) != 0 {
		t.Errorf("Expected 0 translate calls when all targets have user translations, got %d", len(mock.calls))
	}
}

func TestAutoTranslate_TranslatorError(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	expectedErr := errors.New("API error")
	mock := &mockTranslator{
		translateFunc: func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
			return nil, expectedErr
		},
	}
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if !errors.Is(err, expectedErr) {
		t.Errorf("Expected API error, got %v", err)
	}

	if _, ok := tr.Get("fr"); ok {
		t.Error("No translation should exist for 'fr' after error")
	}
}

func TestAutoTranslate_NilResponse(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := &mockTranslator{
		translateFunc: func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
			return nil, nil
		},
	}
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("Expected no error for nil response, got %v", err)
	}
}

func TestAutoTranslate_EmptyResponse(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := &mockTranslator{
		translateFunc: func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
			return &TranslateResponse{Translations: map[string]*Translation{}}, nil
		},
	}
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("Expected no error for empty response, got %v", err)
	}
}

func TestAutoTranslate_NilTranslationInResponse(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := &mockTranslator{
		translateFunc: func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
			return &TranslateResponse{
				Translations: map[string]*Translation{
					"fr": nil,
					"de": {Singular: "Hallo"},
				},
			}, nil
		},
	}
	config := newMockConfig(mock, "fr", "de")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	if tr.IsAutoGenerated("fr") {
		t.Error("nil translation should not have been added for 'fr'")
	}

	de, ok := tr.Get("de")
	if !ok || de.Singular != "Hallo" {
		t.Errorf("Expected de='Hallo', got %v", de)
	}
}

func TestAutoTranslate_CustomSourceLanguage(t *testing.T) {
	tr := &Translations{}
	tr.Add("fr", "Bonjour")

	mock := newMockTranslator()
	config := &TranslatorConfig{
		Translator:      mock,
		SourceLanguage:  "fr",
		TargetLanguages: []string{"en", "de"},
	}

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	if len(mock.calls) != 1 {
		t.Fatalf("Expected 1 call, got %d", len(mock.calls))
	}
	if mock.calls[0].SourceLanguage != "fr" {
		t.Errorf("Expected source language 'fr', got '%s'", mock.calls[0].SourceLanguage)
	}
	if mock.calls[0].Singular != "Bonjour" {
		t.Errorf("Expected singular 'Bonjour', got '%s'", mock.calls[0].Singular)
	}
}

func TestAutoTranslate_DefaultTargetLanguages(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := &TranslatorConfig{Translator: mock}

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	if len(mock.calls) != 1 {
		t.Fatalf("Expected 1 call, got %d", len(mock.calls))
	}

	if len(mock.calls[0].TargetLanguages) != len(DefaultTargetLanguages) {
		t.Errorf("Expected %d target languages, got %d", len(DefaultTargetLanguages), len(mock.calls[0].TargetLanguages))
	}
}

func TestAutoTranslate_ContextCancellation(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	ctx, cancel := context.WithCancel(context.Background())
	cancel()

	cancelErr := errors.New("context canceled")
	mock := &mockTranslator{
		translateFunc: func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
			return nil, cancelErr
		},
	}
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(ctx, config)
	if err == nil {
		t.Error("Expected error from cancelled context")
	}
}

func TestAutoTranslate_SourceTextFromValues(t *testing.T) {
	tr := &Translations{}
	tr.Replace(map[string]*Translation{
		"en": {Singular: "Hello from values"},
	})

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	if len(mock.calls) != 1 {
		t.Fatalf("Expected 1 call, got %d", len(mock.calls))
	}
	if mock.calls[0].Singular != "Hello from values" {
		t.Errorf("Expected source 'Hello from values', got '%s'", mock.calls[0].Singular)
	}
}

func TestAutoTranslate_PartialResponse(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := &mockTranslator{
		translateFunc: func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
			return &TranslateResponse{
				Translations: map[string]*Translation{
					"fr": {Singular: "Bonjour"},
				},
			}, nil
		},
	}
	config := newMockConfig(mock, "fr", "de")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	fr, ok := tr.Get("fr")
	if !ok || fr.Singular != "Bonjour" {
		t.Errorf("Expected 'Bonjour', got %v", fr)
	}

	if _, ok := tr.Get("de"); ok {
		t.Error("Expected 'de' not to exist (partial response)")
	}
}

func TestAutoTranslate_RepeatedCallsRetranslateAutoGenerated(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	callCount := 0
	mock := &mockTranslator{
		translateFunc: func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
			callCount++
			return &TranslateResponse{
				Translations: map[string]*Translation{
					"fr": {Singular: "Bonjour"},
				},
			}, nil
		},
	}
	config := newMockConfig(mock, "fr")

	_ = tr.AutoTranslate(context.Background(), config)
	_ = tr.AutoTranslate(context.Background(), config)

	if callCount != 2 {
		t.Errorf("Expected 2 calls (auto-generated are re-translatable), got %d", callCount)
	}
}

// --- RegenerateTranslations Tests ---

func TestRegenerateTranslations_NilConfig(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	err := tr.RegenerateTranslations(context.Background(), nil)
	if !errors.Is(err, ErrNoTranslator) {
		t.Errorf("Expected ErrNoTranslator, got %v", err)
	}
}

func TestRegenerateTranslations_NilTranslator(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	err := tr.RegenerateTranslations(context.Background(), &TranslatorConfig{})
	if !errors.Is(err, ErrNoTranslator) {
		t.Errorf("Expected ErrNoTranslator, got %v", err)
	}
}

func TestRegenerateTranslations_NoSourceText(t *testing.T) {
	tr := &Translations{}
	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")
	err := tr.RegenerateTranslations(context.Background(), config)
	if !errors.Is(err, ErrNoSourceText) {
		t.Errorf("Expected ErrNoSourceText, got %v", err)
	}
}

func TestRegenerateTranslations_AllAutoGenerated(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr", "de")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	mock.translateFunc = func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
		resp := &TranslateResponse{Translations: make(map[string]*Translation)}
		for _, lang := range req.TargetLanguages {
			resp.Translations[lang] = &Translation{Singular: "regenerated:" + lang}
		}
		return resp, nil
	}

	err = tr.RegenerateTranslations(context.Background(), config)
	if err != nil {
		t.Fatalf("RegenerateTranslations returned error: %v", err)
	}

	fr, _ := tr.Get("fr")
	if fr.Singular != "regenerated:fr" {
		t.Errorf("Expected regenerated French, got '%s'", fr.Singular)
	}

	de, _ := tr.Get("de")
	if de.Singular != "regenerated:de" {
		t.Errorf("Expected regenerated German, got '%s'", de.Singular)
	}
}

func TestRegenerateTranslations_SpecificLanguages(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr", "de", "es")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	mock.calls = nil
	mock.translateFunc = func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
		resp := &TranslateResponse{Translations: make(map[string]*Translation)}
		for _, lang := range req.TargetLanguages {
			resp.Translations[lang] = &Translation{Singular: "regen:" + lang}
		}
		return resp, nil
	}

	err = tr.RegenerateTranslations(context.Background(), config, "fr")
	if err != nil {
		t.Fatalf("RegenerateTranslations returned error: %v", err)
	}

	if len(mock.calls) != 1 {
		t.Fatalf("Expected 1 translate call, got %d", len(mock.calls))
	}
	if len(mock.calls[0].TargetLanguages) != 1 || mock.calls[0].TargetLanguages[0] != "fr" {
		t.Errorf("Expected target [fr], got %v", mock.calls[0].TargetLanguages)
	}

	fr, _ := tr.Get("fr")
	if fr.Singular != "regen:fr" {
		t.Errorf("Expected 'regen:fr', got '%s'", fr.Singular)
	}

	de, _ := tr.Get("de")
	if de.Singular != "de:Hello" {
		t.Errorf("Expected German unchanged 'de:Hello', got '%s'", de.Singular)
	}
}

func TestRegenerateTranslations_SkipsUserProvided(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr", "de")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	// User overrides French
	tr.Add("fr", "Bonjour")

	mock.calls = nil

	err = tr.RegenerateTranslations(context.Background(), config, "fr")
	if err != nil {
		t.Fatalf("RegenerateTranslations returned error: %v", err)
	}

	if len(mock.calls) != 0 {
		t.Errorf("Expected 0 translate calls for user-provided language, got %d", len(mock.calls))
	}

	fr, _ := tr.Get("fr")
	if fr.Singular != "Bonjour" {
		t.Errorf("Expected 'Bonjour', got '%s'", fr.Singular)
	}
}

func TestRegenerateTranslations_NoAutoGenerated(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	tr.Add("fr", "Bonjour")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	err := tr.RegenerateTranslations(context.Background(), config)
	if err != nil {
		t.Fatalf("RegenerateTranslations returned error: %v", err)
	}

	if len(mock.calls) != 0 {
		t.Errorf("Expected 0 translate calls, got %d", len(mock.calls))
	}
}

func TestRegenerateTranslations_TranslatorError(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	expectedErr := errors.New("regen failed")
	mock.translateFunc = func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
		return nil, expectedErr
	}

	err = tr.RegenerateTranslations(context.Background(), config)
	if !errors.Is(err, expectedErr) {
		t.Errorf("Expected regen error, got %v", err)
	}
}

func TestRegenerateTranslations_NilResponse(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	mock.translateFunc = func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
		return nil, nil
	}

	err = tr.RegenerateTranslations(context.Background(), config)
	if err != nil {
		t.Errorf("Expected no error for nil response, got %v", err)
	}
}

func TestRegenerateTranslations_NonAutoGeneratedLanguageIgnored(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	tr.Add("fr", "Bonjour")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	err := tr.RegenerateTranslations(context.Background(), config, "fr")
	if err != nil {
		t.Fatalf("RegenerateTranslations returned error: %v", err)
	}

	if len(mock.calls) != 0 {
		t.Errorf("Expected 0 calls, got %d", len(mock.calls))
	}
}

// --- IsAutoGenerated Tests ---

func TestIsAutoGenerated_NotAutoGenerated(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	tr.Add("fr", "Bonjour")

	if tr.IsAutoGenerated("en") {
		t.Error("Expected 'en' not to be auto-generated")
	}
	if tr.IsAutoGenerated("fr") {
		t.Error("Expected 'fr' not to be auto-generated")
	}
}

func TestIsAutoGenerated_AfterAutoTranslate(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	if !tr.IsAutoGenerated("fr") {
		t.Error("Expected 'fr' to be auto-generated after AutoTranslate")
	}
	if tr.IsAutoGenerated("en") {
		t.Error("Expected 'en' not to be auto-generated")
	}
}

func TestIsAutoGenerated_NonexistentLanguage(t *testing.T) {
	tr := &Translations{}
	if tr.IsAutoGenerated("xx") {
		t.Error("Expected false for nonexistent language")
	}
}

// --- ClearAutoGenerated Tests ---

func TestClearAutoGenerated(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	if !tr.IsAutoGenerated("fr") {
		t.Error("Expected 'fr' to be auto-generated")
	}

	tr.ClearAutoGenerated("fr")

	if tr.IsAutoGenerated("fr") {
		t.Error("Expected 'fr' to no longer be auto-generated after ClearAutoGenerated")
	}
}

func TestClearAutoGenerated_NonexistentLanguage(t *testing.T) {
	tr := &Translations{}
	tr.ClearAutoGenerated("xx")
}

func TestClearAutoGenerated_NilMap(t *testing.T) {
	tr := &Translations{}
	tr.ClearAutoGenerated("fr")
}

// --- AutoGeneratedLanguages Tests ---

func TestAutoGeneratedLanguages_Empty(t *testing.T) {
	tr := &Translations{}
	langs := tr.AutoGeneratedLanguages()
	if len(langs) != 0 {
		t.Errorf("Expected 0 auto-generated languages, got %d", len(langs))
	}
}

func TestAutoGeneratedLanguages_AfterAutoTranslate(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr", "de")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	langs := tr.AutoGeneratedLanguages()
	sort.Strings(langs)
	if len(langs) != 2 {
		t.Fatalf("Expected 2 auto-generated languages, got %d", len(langs))
	}
	if langs[0] != "de" || langs[1] != "fr" {
		t.Errorf("Expected [de, fr], got %v", langs)
	}
}

// --- UserProvidedLanguages Tests ---

func TestUserProvidedLanguages_AllUserProvided(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	tr.Add("fr", "Bonjour")

	langs := tr.UserProvidedLanguages()
	sort.Strings(langs)
	if len(langs) != 2 {
		t.Fatalf("Expected 2 user-provided languages, got %d", len(langs))
	}
	if langs[0] != "en" || langs[1] != "fr" {
		t.Errorf("Expected [en, fr], got %v", langs)
	}
}

func TestUserProvidedLanguages_Mixed(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	tr.Add("fr", "Bonjour")

	mock := newMockTranslator()
	config := newMockConfig(mock, "de")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	langs := tr.UserProvidedLanguages()
	sort.Strings(langs)
	if len(langs) != 2 {
		t.Fatalf("Expected 2 user-provided languages (en, fr), got %d: %v", len(langs), langs)
	}
	if langs[0] != "en" || langs[1] != "fr" {
		t.Errorf("Expected [en, fr], got %v", langs)
	}
}

// --- User Override Protection Tests ---

func TestUserOverrideProtection_AddClearsAutoGenerated(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	if !tr.IsAutoGenerated("fr") {
		t.Error("Expected 'fr' to be auto-generated")
	}

	// User overrides with Add
	tr.Add("fr", "Bonjour")

	if tr.IsAutoGenerated("fr") {
		t.Error("Expected 'fr' auto-generated flag to be cleared after user Add")
	}

	// Subsequent AutoTranslate should NOT override user's French
	mock.calls = nil
	err = tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("Second AutoTranslate returned error: %v", err)
	}

	fr, _ := tr.Get("fr")
	if fr.Singular != "Bonjour" {
		t.Errorf("Expected user-provided 'Bonjour', got '%s'", fr.Singular)
	}

	if len(mock.calls) != 0 {
		t.Errorf("Expected 0 translate calls, got %d", len(mock.calls))
	}
}

func TestUserOverrideProtection_AddTClearsAutoGenerated(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	tr.AddT("fr", &Translation{Singular: "Bonjour", Plural: "Bonjours"})

	if tr.IsAutoGenerated("fr") {
		t.Error("Expected 'fr' auto-generated flag to be cleared after user AddT")
	}
}

func TestUserOverrideProtection_ReplaceClearsAllAutoGenerated(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr", "de")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	tr.Replace(map[string]*Translation{
		"en": {Singular: "Hello"},
		"fr": {Singular: "Bonjour"},
	})

	if tr.IsAutoGenerated("fr") {
		t.Error("Expected 'fr' auto-generated flag to be cleared after Replace")
	}
	if tr.IsAutoGenerated("de") {
		t.Error("Expected 'de' auto-generated flag to be cleared after Replace")
	}
}

// --- Integration Tests ---

func TestIntegration_FullWorkflow(t *testing.T) {
	tr := &Translations{}

	// Step 1: Set English text
	tr.Add("en", "Welcome")

	// Step 2: Auto-translate
	mock := newMockTranslator()
	config := newMockConfig(mock, "fr", "de", "es")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	all := tr.All()
	if len(all) != 4 { // en + fr + de + es
		t.Fatalf("Expected 4 translations, got %d", len(all))
	}

	// Step 3: User provides French translation
	tr.Add("fr", "Bienvenue")

	// Step 4: Auto-translate again (should skip French)
	mock.calls = nil
	err = tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("Second AutoTranslate returned error: %v", err)
	}

	fr, _ := tr.Get("fr")
	if fr.Singular != "Bienvenue" {
		t.Errorf("Expected 'Bienvenue', got '%s'", fr.Singular)
	}

	if len(mock.calls) != 1 {
		t.Fatalf("Expected 1 translate call, got %d", len(mock.calls))
	}
	targets := mock.calls[0].TargetLanguages
	sort.Strings(targets)
	if len(targets) != 2 || targets[0] != "de" || targets[1] != "es" {
		t.Errorf("Expected targets [de, es], got %v", targets)
	}

	// Step 5: Regenerate only German
	mock.calls = nil
	mock.translateFunc = func(ctx context.Context, req TranslateRequest) (*TranslateResponse, error) {
		resp := &TranslateResponse{Translations: make(map[string]*Translation)}
		for _, lang := range req.TargetLanguages {
			resp.Translations[lang] = &Translation{Singular: "new:" + lang}
		}
		return resp, nil
	}

	err = tr.RegenerateTranslations(context.Background(), config, "de")
	if err != nil {
		t.Fatalf("RegenerateTranslations returned error: %v", err)
	}

	de, _ := tr.Get("de")
	if de.Singular != "new:de" {
		t.Errorf("Expected 'new:de', got '%s'", de.Singular)
	}

	// Step 6: Verify final state
	autoLangs := tr.AutoGeneratedLanguages()
	sort.Strings(autoLangs)
	if len(autoLangs) != 2 {
		t.Errorf("Expected 2 auto-generated languages, got %d: %v", len(autoLangs), autoLangs)
	}

	userLangs := tr.UserProvidedLanguages()
	sort.Strings(userLangs)
	if len(userLangs) != 2 { // en + fr
		t.Errorf("Expected 2 user-provided languages, got %d: %v", len(userLangs), userLangs)
	}
}

func TestIntegration_InitialWithAutoTranslate(t *testing.T) {
	tr := &Translations{}
	tr.Initial("en", "Goodbye")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	fr, ok := tr.Get("fr")
	if !ok || fr.Singular != "fr:Goodbye" {
		t.Errorf("Expected 'fr:Goodbye', got %v", fr)
	}
}

func TestIntegration_ReplaceAndAutoTranslate(t *testing.T) {
	tr := &Translations{}
	tr.Replace(map[string]*Translation{
		"en": {Singular: "Goodbye"},
	})

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr", "de")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	all := tr.All()
	if len(all) != 3 {
		t.Errorf("Expected 3 translations, got %d", len(all))
	}
}

// --- DefaultTargetLanguages Test ---

func TestDefaultTargetLanguages(t *testing.T) {
	expected := []string{"es", "fr", "de", "it", "pt", "nl", "ja", "ko", "zh"}
	if len(DefaultTargetLanguages) != len(expected) {
		t.Fatalf("Expected %d default languages, got %d", len(expected), len(DefaultTargetLanguages))
	}
	for i, lang := range expected {
		if DefaultTargetLanguages[i] != lang {
			t.Errorf("Expected DefaultTargetLanguages[%d]='%s', got '%s'", i, lang, DefaultTargetLanguages[i])
		}
	}
}

// --- hasUserTranslation Tests ---

func TestHasUserTranslation_NoTranslation(t *testing.T) {
	tr := &Translations{}
	if tr.hasUserTranslation("fr") {
		t.Error("Expected false for non-existent language")
	}
}

func TestHasUserTranslation_UserProvided(t *testing.T) {
	tr := &Translations{}
	tr.Add("fr", "Bonjour")
	if !tr.hasUserTranslation("fr") {
		t.Error("Expected true for user-provided translation")
	}
}

func TestHasUserTranslation_AutoGenerated(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")
	_ = tr.AutoTranslate(context.Background(), config)

	if tr.hasUserTranslation("fr") {
		t.Error("Expected false for auto-generated translation")
	}
}

// --- targetLanguagesForAutoTranslate Tests ---

func TestTargetLanguagesForAutoTranslate_ExcludesSource(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	config := &TranslatorConfig{
		Translator:      newMockTranslator(),
		TargetLanguages: []string{"en", "fr", "de"},
	}

	targets := tr.targetLanguagesForAutoTranslate(config)
	for _, lang := range targets {
		if lang == "en" {
			t.Error("Source language should be excluded from targets")
		}
	}
}

func TestTargetLanguagesForAutoTranslate_ExcludesUserProvided(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	tr.Add("fr", "Bonjour")

	config := &TranslatorConfig{
		Translator:      newMockTranslator(),
		TargetLanguages: []string{"fr", "de"},
	}

	targets := tr.targetLanguagesForAutoTranslate(config)
	if len(targets) != 1 || targets[0] != "de" {
		t.Errorf("Expected [de], got %v", targets)
	}
}

func TestTargetLanguagesForAutoTranslate_IncludesAutoGenerated(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	_ = tr.AutoTranslate(context.Background(), config)

	targets := tr.targetLanguagesForAutoTranslate(config)
	if len(targets) != 1 || targets[0] != "fr" {
		t.Errorf("Expected [fr] (auto-generated), got %v", targets)
	}
}

// --- Edge Cases ---

func TestAutoTranslate_EmptyTargetLanguages(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")

	mock := newMockTranslator()
	config := &TranslatorConfig{
		Translator:      mock,
		TargetLanguages: []string{},
	}

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}
}

func TestAutoTranslate_RemoveThenAutoTranslate(t *testing.T) {
	tr := &Translations{}
	tr.Add("en", "Hello")
	tr.Add("fr", "Bonjour")

	// Remove French
	tr.Remove("fr")

	mock := newMockTranslator()
	config := newMockConfig(mock, "fr")

	err := tr.AutoTranslate(context.Background(), config)
	if err != nil {
		t.Fatalf("AutoTranslate returned error: %v", err)
	}

	// French should now be auto-generated
	fr, ok := tr.Get("fr")
	if !ok || fr.Singular != "fr:Hello" {
		t.Errorf("Expected auto-generated fr after remove, got %v (ok=%v)", fr, ok)
	}
	if !tr.IsAutoGenerated("fr") {
		t.Error("Expected 'fr' to be auto-generated after remove + auto-translate")
	}
}
