package keystone

import (
	"context"
	"errors"
)

// DefaultTargetLanguages is the default set of languages for auto-translation
var DefaultTargetLanguages = []string{
	"es", // Spanish
	"fr", // French
	"de", // German
	"it", // Italian
	"pt", // Portuguese
	"nl", // Dutch
	"ja", // Japanese
	"ko", // Korean
	"zh", // Chinese (Simplified)
}

// TranslateRequest represents a request to translate text from a source language
type TranslateRequest struct {
	// SourceLanguage is the language code of the source text (e.g. "en")
	SourceLanguage string

	// Singular is the singular form of the source text
	Singular string

	// Plural is the plural form of the source text (may be empty)
	Plural string

	// TargetLanguages is the list of language codes to translate into
	TargetLanguages []string
}

// TranslateResponse represents the result of a translation request
type TranslateResponse struct {
	// Translations map language codes to their translated text
	Translations map[string]*Translation
}

// Translator is the interface that any AI translation provider must implement.
// Implementations should handle authentication, rate limiting, and retries internally.
type Translator interface {
	// Translate translates text from the source language into the given target languages.
	// It should return translations for as many target languages as possible.
	// Partial results are acceptable: if some languages fail, return what succeeded.
	// The context can be used for cancellation and timeouts.
	Translate(ctx context.Context, req TranslateRequest) (*TranslateResponse, error)
}

// TranslatorConfig holds the configuration for auto-translation
type TranslatorConfig struct {
	// Translator is the AI translation provider implementation
	Translator Translator

	// SourceLanguage is the language code to translate from (default: "en")
	SourceLanguage string

	// TargetLanguages is the list of language codes to translate into.
	// If empty, DefaultTargetLanguages is used.
	TargetLanguages []string
}

// GetSourceLanguage returns the configured source language, defaulting to "en"
func (c *TranslatorConfig) GetSourceLanguage() string {
	if c.SourceLanguage != "" {
		return c.SourceLanguage
	}
	return "en"
}

// GetTargetLanguages returns the configured target languages, defaulting to DefaultTargetLanguages
func (c *TranslatorConfig) GetTargetLanguages() []string {
	if len(c.TargetLanguages) > 0 {
		return c.TargetLanguages
	}
	return DefaultTargetLanguages
}

// noOpTranslator is the default translator that does nothing
type noOpTranslator struct{}

// Translate returns an empty response, performing no translation
func (n *noOpTranslator) Translate(_ context.Context, _ TranslateRequest) (*TranslateResponse, error) {
	return &TranslateResponse{Translations: make(map[string]*Translation)}, nil
}

// NoOpTranslator returns a translator that performs no translations.
// This is the default when no AI provider is configured.
func NoOpTranslator() Translator {
	return &noOpTranslator{}
}

// ErrNoSourceText is returned when auto-translate is called with no source text available
var ErrNoSourceText = errors.New("no source text available for translation")

// ErrNoTranslator is returned when auto-translate is called with no translator configured
var ErrNoTranslator = errors.New("no translator configured")

// AutoTranslate generates AI translations for the configured target languages.
// It uses the source language text (default: English) as input and translates
// into all configured target languages that do not already have a user-provided translation.
//
// User-provided translations are never overridden. Only languages that have no existing
// translation, or that were previously auto-generated, will be populated.
func (t *Translations) AutoTranslate(ctx context.Context, config *TranslatorConfig) error {
	if config == nil || config.Translator == nil {
		return ErrNoTranslator
	}

	t.prepare()

	sourceLang := config.GetSourceLanguage()

	// Get the source text
	source, ok := t.Get(sourceLang)
	if !ok || source == nil || source.Singular == "" {
		return ErrNoSourceText
	}

	// Determine which target languages need translation
	targets := t.targetLanguagesForAutoTranslate(config)
	if len(targets) == 0 {
		return nil
	}

	// Call the translator
	resp, err := config.Translator.Translate(ctx, TranslateRequest{
		SourceLanguage:  sourceLang,
		Singular:        source.Singular,
		Plural:          source.Plural,
		TargetLanguages: targets,
	})
	if err != nil {
		return err
	}

	if resp == nil || len(resp.Translations) == 0 {
		return nil
	}

	// Apply the translations, marking each as auto-generated
	for lang, translation := range resp.Translations {
		if translation == nil {
			continue
		}
		t.addAutoGenerated(lang, translation)
	}

	return nil
}

// RegenerateTranslations regenerates auto-generated translations for the specified languages.
// If no languages are provided, all auto-generated translations are regenerated.
// Regeneration never affects user-provided translations.
func (t *Translations) RegenerateTranslations(ctx context.Context, config *TranslatorConfig, languages ...string) error {
	if config == nil || config.Translator == nil {
		return ErrNoTranslator
	}

	t.prepare()

	sourceLang := config.GetSourceLanguage()

	// Get the source text
	source, ok := t.Get(sourceLang)
	if !ok || source == nil || source.Singular == "" {
		return ErrNoSourceText
	}

	// Determine which languages to regenerate
	var targets []string
	if len(languages) == 0 {
		// Regenerate all auto-generated languages
		targets = t.autoGeneratedLanguages()
	} else {
		// Only regenerate the specified languages if they are auto-generated
		for _, lang := range languages {
			if t.IsAutoGenerated(lang) {
				targets = append(targets, lang)
			}
		}
	}

	if len(targets) == 0 {
		return nil
	}

	// Call the translator
	resp, err := config.Translator.Translate(ctx, TranslateRequest{
		SourceLanguage:  sourceLang,
		Singular:        source.Singular,
		Plural:          source.Plural,
		TargetLanguages: targets,
	})
	if err != nil {
		return err
	}

	if resp == nil || len(resp.Translations) == 0 {
		return nil
	}

	// Apply the regenerated translations
	for lang, translation := range resp.Translations {
		if translation == nil {
			continue
		}
		t.addAutoGenerated(lang, translation)
	}

	return nil
}

// targetLanguagesForAutoTranslate returns target languages that need auto-translation.
// It excludes the source language and any language that already has a user-provided translation.
func (t *Translations) targetLanguagesForAutoTranslate(config *TranslatorConfig) []string {
	sourceLang := config.GetSourceLanguage()
	allTargets := config.GetTargetLanguages()

	var targets []string
	for _, lang := range allTargets {
		if lang == sourceLang {
			continue
		}

		// Skip if there is an existing user-provided (non-auto-generated) translation
		if t.hasUserTranslation(lang) {
			continue
		}

		targets = append(targets, lang)
	}
	return targets
}

// hasUserTranslation returns true if the language has a translation that was NOT auto-generated
func (t *Translations) hasUserTranslation(lang string) bool {
	_, exists := t.Get(lang)
	if !exists {
		return false
	}
	return !t.IsAutoGenerated(lang)
}

// IsAutoGenerated returns whether a translation for the given language was auto-generated
func (t *Translations) IsAutoGenerated(lang string) bool {
	t.prepare()
	if t.autoGenerated == nil {
		return false
	}
	return t.autoGenerated[lang]
}

// AutoGeneratedLanguages returns all language codes that have auto-generated translations
func (t *Translations) AutoGeneratedLanguages() []string {
	t.prepare()
	return t.autoGeneratedLanguages()
}

// UserProvidedLanguages returns all language codes that have user-provided (non-auto-generated) translations
func (t *Translations) UserProvidedLanguages() []string {
	t.prepare()
	all := t.All()
	var langs []string
	for lang := range all {
		if !t.IsAutoGenerated(lang) {
			langs = append(langs, lang)
		}
	}
	return langs
}

// autoGeneratedLanguages returns all auto-generated language codes (internal helper)
func (t *Translations) autoGeneratedLanguages() []string {
	if t.autoGenerated == nil {
		return nil
	}
	var langs []string
	for lang, isAuto := range t.autoGenerated {
		if isAuto {
			langs = append(langs, lang)
		}
	}
	return langs
}

// addAutoGenerated adds a translation and marks it as auto-generated
func (t *Translations) addAutoGenerated(lang string, translation *Translation) {
	t.AddT(lang, translation)
	t.markAutoGenerated(lang)
}

// markAutoGenerated marks a language as auto-generated
func (t *Translations) markAutoGenerated(lang string) {
	if t.autoGenerated == nil {
		t.autoGenerated = make(map[string]bool)
	}
	t.autoGenerated[lang] = true
}

// ClearAutoGenerated removes the auto-generated flag for a language.
// This is called automatically when a user provides their own translation via Add or AddT.
func (t *Translations) ClearAutoGenerated(lang string) {
	if t.autoGenerated != nil {
		delete(t.autoGenerated, lang)
	}
}
